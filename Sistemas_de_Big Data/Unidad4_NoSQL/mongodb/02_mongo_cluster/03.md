## **3. Opciones y Comandos de Administración**

### **3.1. Comandos administrativos principales**

MongoDB proporciona un amplio conjunto de comandos administrativos que permiten gestionar todos los aspectos del sistema. Estos comandos se ejecutan mediante el método `db.runCommand()` o su variante `db.adminCommand()` cuando necesitamos ejecutarlos específicamente contra la base de datos `admin`. [mongodb](https://www.mongodb.com/docs/manual/reference/command/nav-administration/)

Los comandos administrativos se organizan en varias categorías funcionales. Comprender esta organización es fundamental para cualquier administrador, ya que cada categoría aborda aspectos específicos de la gestión del sistema.

**Comandos de diagnóstico y estado:**

El comando `serverStatus` es uno de los más importantes para monitorización, ya que devuelve un documento extenso con métricas del servidor:

```javascript
db.adminCommand({ serverStatus: 1 })
```

Este comando proporciona información sobre conexiones activas, operaciones de red, uso de memoria, estadísticas del motor de almacenamiento (WiredTiger), información sobre replicación, métricas de sharding y mucho más. La salida puede ser abrumadora, pero podemos solicitar solo secciones específicas:

```javascript
// Solo métricas de conexiones y memoria
db.adminCommand({ 
  serverStatus: 1, 
  connections: 1, 
  mem: 1 
})
```

El comando `currentOp` muestra las operaciones que se están ejecutando actualmente en el servidor, fundamental para identificar consultas problemáticas:

```javascript
// Ver todas las operaciones en curso
db.adminCommand({
  currentOp: true,
  $all: true
})

// Ver solo operaciones que llevan más de 5 segundos
db.adminCommand({
  currentOp: true,
  secs_running: { $gte: 5 }
})
```

**Ejemplo práctico de identificación y terminación de consulta lenta:**

Imaginemos que recibimos alertas de que la base de datos está respondiendo lentamente. Ejecutamos `currentOp` y encontramos:

```javascript
db.currentOp()
{
  "inprog": [
    {
      "opid": 12345678,
      "active": true,
      "secs_running": 450,
      "op": "query",
      "ns": "ventas.pedidos",
      "query": {
        "find": "pedidos",
        "filter": { "fecha": { "$gte": ISODate("2020-01-01") } }
      },
      "client": "192.168.1.50:54321"
    }
  ]
}
```

Esta consulta lleva 450 segundos ejecutándose (7.5 minutos), probablemente porque falta un índice en el campo `fecha`. Podemos terminarla con:

```javascript
db.killOp(12345678)
```

**Comandos de gestión de colecciones:**

El comando `collMod` permite modificar opciones de colecciones existentes sin necesidad de recrearlas: [mongodb](https://www.mongodb.com/docs/atlas/data-federation/supported-unsupported/administration-commands/)

```javascript
// Activar validación de esquema en una colección existente
db.runCommand({
  collMod: "clientes",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["email", "nombre"],
      properties: {
        email: {
          bsonType: "string",
          pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
        },
        nombre: {
          bsonType: "string",
          minLength: 2
        }
      }
    }
  },
  validationLevel: "moderate",  // No valida documentos existentes
  validationAction: "warn"      // Solo advierte, no rechaza
})
```

Este comando es especialmente útil en producción cuando necesitamos añadir validaciones progresivamente sin afectar datos existentes.

El comando `renameCollection` permite renombrar colecciones, pero requiere ejecutarse contra la base de datos `admin`: [docs.huihoo](https://docs.huihoo.com/mongodb/3.4/reference/method/db.adminCommand/index.html)

```javascript
db.adminCommand({
  renameCollection: "ventas.pedidos",
  to: "ventas.pedidos_2025",
  dropTarget: false  // No sobrescribir si ya existe
})
```

**Comandos de mantenimiento:**

El comando `compact` libera espacio en disco desfragmentando colecciones e índices:

```javascript
db.runCommand({ compact: "logs", force: true })
```

Advertencia: `compact` bloquea la colección durante su ejecución y puede tardar horas en colecciones grandes. En un Replica Set, es mejor ejecutarlo secuencialmente en cada secundario y luego hacer un stepDown del primario.

El comando `reIndex` reconstruye todos los índices de una colección: [docs.huihoo](https://docs.huihoo.com/mongodb/3.4/reference/command/nav-administration/index.html)

```javascript
db.runCommand({ reIndex: "productos" })
```

Este comando también es bloqueante y raramente necesario en MongoDB moderno, ya que WiredTiger mantiene los índices eficientemente. Solo se recomienda si detectamos corrupción de índices.

**Comandos de gestión de base de datos:**

```javascript
// Obtener estadísticas de una base de datos
db.stats()

// O con más detalle
db.runCommand({ dbStats: 1, scale: 1024 })  // En KB

// Listar todas las bases de datos
db.adminCommand({ listDatabases: 1 })

// Eliminar una base de datos (¡cuidado!)
db.dropDatabase()
```

### **3.2. Gestión de colecciones y bases de datos**

La gestión eficiente de colecciones y bases de datos va más allá de crear y eliminar elementos. Implica comprender cómo MongoDB organiza los datos físicamente y cómo optimizar ese almacenamiento.

**Creación de colecciones con opciones específicas:**

Aunque MongoDB crea colecciones automáticamente al insertar el primer documento, muchas veces necesitamos especificar opciones al crear la colección:

```javascript
// Colección limitada por tamaño (capped collection)
db.createCollection("logs_aplicacion", {
  capped: true,
  size: 104857600,      // 100MB
  max: 50000            // Máximo 50,000 documentos
})
```

Las colecciones capped funcionan como buffers circulares: cuando se alcanza el límite, los documentos más antiguos se sobrescriben automáticamente. Son ideales para logs, sensores o cualquier dato donde solo nos interesan los valores recientes.

**Colecciones con validación de esquema:**

MongoDB es schemaless, pero podemos imponer validaciones cuando necesitamos garantías de estructura:

```javascript
db.createCollection("empleados", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["nombre", "email", "departamento", "fecha_alta"],
      properties: {
        nombre: {
          bsonType: "string",
          description: "Nombre completo del empleado"
        },
        email: {
          bsonType: "string",
          pattern: "^.+@empresa\\.com$",
          description: "Debe ser un email corporativo"
        },
        departamento: {
          enum: ["IT", "RRHH", "Ventas", "Marketing"],
          description: "Departamento válido"
        },
        salario: {
          bsonType: "number",
          minimum: 18000,
          maximum: 250000
        },
        fecha_alta: {
          bsonType: "date"
        }
      }
    }
  },
  validationLevel: "strict",    // Validar todos los documentos
  validationAction: "error"     // Rechazar documentos inválidos
})
```

Si intentamos insertar un documento que no cumpla el esquema:

```javascript
db.empleados.insertOne({
  nombre: "Juan Pérez",
  email: "juan@gmail.com",  // No es @empresa.com
  departamento: "IT",
  fecha_alta: new Date()
})

// Error: Document failed validation
```

**Gestión de vistas (views):**

Las vistas son consultas predefenidas que se comportan como colecciones de solo lectura:

```javascript
// Vista que muestra solo pedidos completados del último año
db.createView(
  "pedidos_recientes_completados",
  "pedidos",
  [
    {
      $match: {
        estado: "completado",
        fecha: { $gte: new Date("2025-01-01") }
      }
    },
    {
      $project: {
        cliente: 1,
        total: 1,
        fecha: 1,
        items: { $size: "$productos" }
      }
    }
  ]
)

// Usar la vista como cualquier colección
db.pedidos_recientes_completados.find({ total: { $gt: 100 } })
```

Las vistas son especialmente útiles para seguridad (exponer solo ciertos campos) y simplificar consultas complejas frecuentes.

### **3.3. Gestión de usuarios y seguridad**

La gestión de usuarios en MongoDB se basa en un sistema de roles y privilegios granular. MongoDB opera bajo el principio de seguridad por defecto: si la autenticación está habilitada, cualquier acción requiere permisos explícitos. [severalnines](https://severalnines.com/blog/overview-mongodb-user-management/)

**Roles built-in principales:**

MongoDB proporciona roles predefinidos organizados por categoría: [severalnines](https://severalnines.com/blog/overview-mongodb-user-management/)

**Roles de base de datos:**
- `read`: Leer datos de todas las colecciones no-sistema
- `readWrite`: Leer y escribir en todas las colecciones no-sistema
- `dbAdmin`: Administrar la base de datos (índices, estadísticas, compactación)
- `userAdmin`: Gestionar usuarios y roles
- `dbOwner`: Combina readWrite, dbAdmin y userAdmin

**Roles de cluster:**
- `clusterMonitor`: Monitorizar herramientas de monitorización
- `clusterManager`: Gestionar y monitorizar el cluster
- `hostManager`: Gestionar servidores individuales
- `clusterAdmin`: Máximos privilegios de gestión de cluster

**Roles de backup:**
- `backup`: Privilegios mínimos para backup
- `restore`: Privilegios para restaurar backups

**Rol de superusuario:**
- `root`: Acceso completo a todos los recursos (usar con extrema precaución)

**Ejemplo de creación de usuarios con diferentes roles:**

```javascript
// Usuario administrador del sistema (solo uno debería existir)
use admin
db.createUser({
  user: "admin_master",
  pwd: "contraseña_muy_segura_123!",
  roles: [
    { role: "root", db: "admin" }
  ]
})

// Usuario para backup
db.createUser({
  user: "backup_user",
  pwd: "backup_password_456!",
  roles: [
    { role: "backup", db: "admin" },
    { role: "restore", db: "admin" }
  ]
})

// Usuario de monitorización (para Prometheus, Grafana, etc.)
db.createUser({
  user: "monitoring",
  pwd: "monitoring_pass_789!",
  roles: [
    { role: "clusterMonitor", db: "admin" },
    { role: "read", db: "local" }
  ]
})

// Usuario de aplicación con acceso limitado
use ventas
db.createUser({
  user: "app_ventas",
  pwd: "app_password_abc!",
  roles: [
    { role: "readWrite", db: "ventas" },
    { role: "read", db: "clientes" }
  ]
})
```

**Creación de roles personalizados:**

Para casos más específicos, creamos roles custom: [severalnines](https://severalnines.com/blog/overview-mongodb-user-management/)

```javascript
use admin
db.createRole({
  role: "analista_datos",
  privileges: [
    {
      // Puede leer de todas las colecciones de ventas
      resource: { db: "ventas", collection: "" },
      actions: ["find", "listIndexes", "listCollections"]
    },
    {
      // Puede escribir solo en la colección de reportes
      resource: { db: "ventas", collection: "reportes" },
      actions: ["insert", "update"]
    },
    {
      // Puede ejecutar agregaciones (importante para analítica)
      resource: { db: "ventas", collection: "" },
      actions: ["aggregate"]
    }
  ],
  roles: []  // No hereda de otros roles
})

// Asignar el rol a un usuario
db.createUser({
  user: "maria_analista",
  pwd: "maria_password!",
  roles: [
    { role: "analista_datos", db: "admin" }
  ]
})
```

**Gestión de usuarios existentes:**

```javascript
// Ver información de un usuario
db.getUser("app_ventas")

// Añadir roles adicionales
db.grantRolesToUser(
  "app_ventas",
  [
    { role: "read", db: "productos" }
  ]
)

// Remover roles
db.revokeRolesFromUser(
  "app_ventas",
  [
    { role: "read", db: "productos" }
  ]
)

// Cambiar contraseña
db.changeUserPassword("app_ventas", "nueva_contraseña_segura!")

// Eliminar usuario
db.dropUser("usuario_temporal")
```

### **3.4. Configuración del servidor (mongod.conf)**

El archivo de configuración `mongod.conf` es el mecanismo principal para configurar instancias de MongoDB de forma persistente. Este archivo utiliza formato YAML y se especifica al iniciar mongod con la opción `--config`: [docs.percona](https://docs.percona.com/percona-operator-for-mongodb/options.html)

```bash
mongod --config /etc/mongod.conf
```

**Estructura básica de mongod.conf:**

```yaml
# Configuración de red
net:
  port: 27017
  bindIp: 127.0.0.1,192.168.1.10  # IPs donde escuchar
  maxIncomingConnections: 65536
  tls:
    mode: requireTLS
    certificateKeyFile: /etc/ssl/mongodb.pem
    CAFile: /etc/ssl/ca.pem

# Configuración de almacenamiento
storage:
  dbPath: /var/lib/mongodb
  journal:
    enabled: true
    commitIntervalMs: 100
  engine: wiredTiger
  wiredTiger:
    engineConfig:
      cacheSizeGB: 16  # Memoria para caché (por defecto 50% RAM)
      journalCompressor: snappy
    collectionConfig:
      blockCompressor: snappy
    indexConfig:
      prefixCompression: true

# Configuración de logs
systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  logRotate: reopen
  verbosity: 0  # 0=info, 1-5=niveles de debug
  component:
    query:
      verbosity: 1  # Más detalle en queries
    replication:
      verbosity: 2  # Aún más en replicación

# Profiling y diagnóstico
operationProfiling:
  mode: slowOp
  slowOpThresholdMs: 100  # Registrar queries > 100ms

# Seguridad
security:
  authorization: enabled
  keyFile: /etc/mongodb-keyfile  # Para autenticación inter-nodos
  javascriptEnabled: false  # Deshabilitar eval() por seguridad

# Replicación
replication:
  replSetName: rsProduccion
  oplogSizeMB: 10240  # 10GB de oplog

# Sharding (solo para config servers o mongos)
sharding:
  clusterRole: shardsvr  # O configsvr para config servers
```

**Ejemplo de configuración optimizada para producción:**

```yaml
# /etc/mongod-produccion.conf

net:
  port: 27017
  bindIp: 0.0.0.0  # En producción, usar IPs específicas
  maxIncomingConnections: 10000
  compression:
    compressors: snappy,zstd

storage:
  dbPath: /data/mongodb
  directoryPerDB: true  # Cada DB en su propio directorio
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: 32
      statisticsLogDelaySecs: 300  # Estadísticas cada 5 min
    collectionConfig:
      blockCompressor: zstd  # Mejor compresión que snappy
    indexConfig:
      prefixCompression: true

systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
  logRotate: reopen
  timeStampFormat: iso8601-utc

operationProfiling:
  mode: slowOp
  slowOpThresholdMs: 50

security:
  authorization: enabled
  keyFile: /etc/mongodb/keyfile

replication:
  replSetName: rs_app_prod
  enableMajorityReadConcern: true

setParameter:
  enableLocalhostAuthBypass: false
  authenticationMechanisms: SCRAM-SHA-256
  maxIndexBuildMemoryUsageMegabytes: 2048
```

**Rotación de logs:**

Para rotar logs sin reiniciar MongoDB:

```javascript
db.adminCommand({ logRotate: 1 })
```

O configurar rotación automática con logrotate en Linux:

```bash
# /etc/logrotate.d/mongodb
/var/log/mongodb/*.log {
    daily
    rotate 30
    compress
    dateext
    missingok
    notifempty
    sharedscripts
    postrotate
        /bin/kill -SIGUSR1 $(cat /var/lib/mongodb/mongod.lock 2>/dev/null) 2>/dev/null || true
    endscript
}
```

### **3.5. Herramientas de administración (mongosh, Compass, Ops Manager)**

MongoDB proporciona varias herramientas para facilitar la administración, cada una con sus propios casos de uso.

**mongosh (MongoDB Shell):**

Es la interfaz de línea de comandos moderna de MongoDB, reemplazando al antiguo mongo shell. Está basada en Node.js y proporciona un entorno JavaScript completo:

```javascript
// Conectar a un Replica Set con autenticación
mongosh "mongodb://admin:password@mongo1:27017,mongo2:27017,mongo3:27017/?replicaSet=rsProduccion&authSource=admin"

// Scripts útiles de administración
// 1. Encontrar colecciones grandes
db.adminCommand({ listDatabases: 1 }).databases.forEach(database => {
  let mdb = db.getSiblingDB(database.name);
  mdb.getCollectionNames().forEach(col => {
    let stats = mdb[col].stats();
    if (stats.size > 1073741824) {  // > 1GB
      print(`${database.name}.${col}: ${(stats.size/1073741824).toFixed(2)} GB`);
    }
  });
});

// 2. Verificar estado de replicación en todos los nodos
rs.status().members.forEach(member => {
  print(`${member.name}: ${member.stateStr}, lag: ${member.optime ? member.optime.ts : 'N/A'}`);
});
```

**MongoDB Compass:**

GUI oficial de MongoDB que permite explorar datos, crear consultas visualmente, analizar esquemas y gestionar índices. Es especialmente útil para:

- Visualizar la distribución de datos en un cluster sharded
- Diseñar agregaciones con una interfaz visual
- Analizar el rendimiento de consultas con explain plans visuales
- Gestionar índices de forma intuitiva

**MongoDB Ops Manager (On-Premise) / Atlas (Cloud):**

Soluciones empresariales para gestión completa de clusters:

- Despliegue automatizado de clusters
- Monitorización en tiempo real con alertas
- Backup automatizado con point-in-time recovery
- Gestión de actualizaciones sin downtime
- Seguridad y auditoría centralizada

En entornos de producción críticos, estas herramientas son prácticamente imprescindibles, ya que reducen enormemente la carga operacional del equipo de administración.

Con estos fundamentos de administración básica, estamos preparados para abordar aspectos más avanzados como el escalado y la monitorización en los siguientes capítulos.

***

¿Continuamos con el Capítulo 4?