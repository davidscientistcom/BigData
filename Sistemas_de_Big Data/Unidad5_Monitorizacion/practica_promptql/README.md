# Registro de Fallos y Modificaciones en la Configuración de Prometheus y Node Exporter

Este documento detalla los problemas encontrados durante la configuración de Prometheus y Node Exporter, así como las modificaciones realizadas para resolverlos.

## Problemas y Soluciones

### Problema 1: `docker compose up` no encuentra el archivo de configuración
**Descripción:**
Al intentar ejecutar `docker compose up`, se generó un error indicando que no se encontró el archivo de configuración `prometheus.yml`.

**Causa:**
El archivo `prometheus.yml` no existía en el directorio especificado en el archivo `docker-compose.yml`.

**Solución:**
Se creó un archivo `prometheus.yml` con la configuración básica necesaria para Prometheus y Node Exporter.

---

### Problema 2: Conflicto de nombres de contenedores
**Descripción:**
El contenedor `prometheus` no pudo iniciarse debido a un conflicto con un contenedor existente que ya utilizaba el mismo nombre.

**Causa:**
Un contenedor anterior con el nombre `prometheus` estaba en ejecución.

**Solución:**
Se eliminó el contenedor en conflicto utilizando el comando:
```bash
docker rm -f prometheus
```
Posteriormente, se reiniciaron los servicios con `docker compose up -d`.

---

### Problema 3: Puerto 9100 ya en uso
**Descripción:**
El contenedor `node-exporter` no pudo iniciarse debido a que el puerto `9100` ya estaba en uso.

**Causa:**
Otro proceso o contenedor estaba utilizando el puerto `9100`.

**Solución:**
Se detuvieron y eliminaron todos los contenedores en ejecución con los comandos:
```bash
docker ps -q | xargs docker stop
docker ps -a -q | xargs docker rm
```
Luego, se reiniciaron los servicios con `docker compose up -d`.

---

### Problema 4: `node-exporter` no accesible desde Prometheus
**Descripción:**
Prometheus no podía acceder al endpoint de métricas de `node-exporter` en `http://node-exporter:9100/metrics`.

**Causa:**
El contenedor de Prometheus no podía resolver el nombre de host `node-exporter` dentro de la red de Docker.

**Solución:**
Se actualizó el archivo `prometheus.yml` para usar la dirección IP del contenedor `node-exporter` en lugar de su nombre de host:
```yaml
- job_name: 'node-exporter'
  static_configs:
    - targets: ['172.19.0.2:9100']
```
Posteriormente, se reinició el contenedor de Prometheus:
```bash
docker compose restart prometheus
```

---

### Problema 5: Prometheus no puede acceder a su propio endpoint
**Descripción:**
El endpoint de Prometheus en `http://localhost:9090/metrics` no está siendo scrapeado correctamente.

**Causa:**
El contenedor de Prometheus no puede resolver `localhost` como su propia dirección dentro de la red de Docker.

**Solución:**
Se actualizará el archivo `prometheus.yml` para que Prometheus utilice su propia dirección IP en lugar de `localhost`. Esto se hará en el siguiente paso.

---

## Próximos pasos
1. Actualizar el archivo `prometheus.yml` para que Prometheus utilice su dirección IP en el objetivo `localhost:9090`.
2. Reiniciar los servicios para aplicar los cambios.
3. Verificar que ambos endpoints (`prometheus` y `node-exporter`) estén funcionando correctamente.

---

Este documento se actualizará conforme se realicen más cambios y se resuelvan los problemas.

## Verificación final y comandos usados

Realicé las comprobaciones finales desde el host y desde la red de Docker para asegurar que los enlaces en la UI sean accesibles cuando corresponda.

- Comprobación rápida de los endpoints desde el host (GET y código HTTP):

```bash
# Prometheus (primera líneas de salida)
curl -sS http://localhost:9090/metrics | sed -n '1,12p'
# Resultado HTTP: 200

# Node Exporter (primera líneas de salida)
curl -sS http://localhost:9100/metrics | sed -n '1,12p'
# Resultado HTTP: 200
```

Ejemplo de salida (recortada):

```
# from Prometheus /metrics (ejemplo):
# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.
# TYPE go_gc_cycles_automatic_gc_cycles_total counter
go_gc_cycles_automatic_gc_cycles_total 10
...

# from node-exporter /metrics (ejemplo):
# HELP go_gc_duration_seconds A summary of the wall-time pause (stop-the-world) duration in garbage collection cycles.
# TYPE go_gc_duration_seconds summary
go_gc_duration_seconds{quantile="0"} 1.7745e-05
...
```

- Comprobación del estado de targets en la API de Prometheus (muestra `scrapeUrl` y `health`):

```bash
curl -sS http://localhost:9090/api/v1/targets | jq '.data.activeTargets[] | {scrapePool: .scrapePool, health: .health, lastScrape: .lastScrape, scrapedUrl: .scrapeUrl}'
```

Ejemplo de resultado obtenido:

```
{
  "scrapePool": "node-exporter",
  "health": "up",
  "lastScrape": "2026-01-19T17:38:58.491591668Z",
  "scrapedUrl": "http://localhost:9100/metrics"
}
{
  "scrapePool": "prometheus",
  "health": "up",
  "lastScrape": "2026-01-19T17:38:55.584557961Z",
  "scrapedUrl": "http://localhost:9090/metrics"
}
```

- Probar resolución/accseso desde la red de Docker (útil si quieres validar nombres de servicio):

```bash
docker run --rm --network nosubir_monitoring curlimages/curl:8.4.0 -sS -I http://prometheus:9090/metrics
docker run --rm --network nosubir_monitoring curlimages/curl:8.4.0 -sS -I http://node-exporter:9100/metrics
```

Notas importantes para alumnos:

- Si en la UI de Prometheus el `Endpoint` aparece como `http://node-exporter:9100/metrics` pero al hacer click desde el navegador no se abre, es porque `node-exporter:9100` es resolvible solo dentro de la red de Docker. Desde el host hay que usar `localhost:9100` (si el puerto está publicado) o bien probar desde un contenedor dentro de la red.
- Para que los enlaces en la UI apunten a `localhost` (y funcionen al pincharlos desde el navegador del host) se puede ejecutar Prometheus en `network_mode: host` o bien dejar Prometheus en bridge y entender que los enlaces que usan nombres de servicio sólo son válidos dentro de la red de contenedores.
 - En este repositorio he configurado ambos servicios (`prometheus` y `node-exporter`) para ejecutarse en `network_mode: host`. Esto garantiza que los enlaces que aparecen en la UI de Prometheus apunten a `http://localhost:...` y sean clicables desde el navegador del host — requisito necesario en entornos institucionales con restricciones de red.
- Algunas imágenes de contenedor no incluyen herramientas de red (p. ej. `curl`) por defecto; para pruebas desde la red es recomendable usar contenedores ligeros con `curl` (ejemplos arriba).

Documenta estos pasos en tus ejercicios: pide a los alumnos que reproduzcan las comprobaciones anteriores para entender la diferencia entre accesibilidad desde el host y desde la red de Docker.

## Explicación de los comandos usados
Aquí se explican con detalle los comandos que aparecen en la sección de diagnóstico para que los alumnos entiendan qué hacen y por qué son útiles.

- `curl -sS http://localhost:9090/metrics | sed -n '1,10p'`
  - `curl`: cliente HTTP desde línea de comandos.
  - `-sS`: `-s` silencioso (no barra de progreso), `-S` muestra errores si ocurren (útil junto con `-s`).
  - `| sed -n '1,10p'`: `sed` imprime solo las primeras 10 líneas de la salida (evita mostrar todo el volcado de métricas).

- `curl -I http://localhost:9090/metrics`
  - `-I` hace una petición HEAD (solo cabeceras). Atención: algunos endpoints no implementan HEAD correctamente y devuelven `405 Method Not Allowed` (el endpoint existe y requiere GET). Si ves 405, prueba un GET normal.

- `curl -sS -o /dev/null -w '%{http_code}\n' http://localhost:9090/metrics`
  - `-o /dev/null` descarta el cuerpo de la respuesta.
  - `-w '%{http_code}\n'` muestra solo el código HTTP devuelto (200, 404, 500, ...). Útil para chequear rápidamente disponibilidad.

- `curl -sS http://localhost:9090/api/v1/targets | jq '.data.activeTargets[] | {scrapePool: .scrapePool, health: .health, scrapedUrl: .scrapeUrl}'`
  - El endpoint `/api/v1/targets` devuelve JSON con información de scraping.
  - `jq` es una utilidad para filtrar y formatear JSON desde la línea de comandos.
  - Con esta combinación puedes ver qué `scrapeUrl` está usando Prometheus y el estado (`health`) de cada target.

- `docker run --rm --network nosubir_monitoring curlimages/curl:8.4.0 -sS -I http://prometheus:9090/metrics`
  - Ejecuta un contenedor temporal (`--rm` lo elimina al terminar) conectado a la red `nosubir_monitoring` para comprobar resoluciones DNS y accesos dentro de la red de Docker.
  - `curlimages/curl` es una imagen que trae `curl` preinstalado (evita problemas con imágenes mínimas que no incluyen herramientas de red).
  - Esta prueba simula lo que puede hacer Prometheus (que vive en la red de Docker) y confirma que `prometheus` y `node-exporter` son alcanzables desde otros contenedores.

Consejo práctico: si dentro de un contenedor falta `curl` o `wget`, no asumas que el servicio no funciona; prueba con un contenedor temporal `curlimages/curl` conectado a la misma red.

## Por qué usamos `network_mode: host` aquí
- En entornos con restricciones de red (por ejemplo, en institutos o redes corporativas) el modo bridge puede no funcionar correctamente porque las políticas de red bloquean o limitan el tráfico entre contenedores y el host. Ejecutar los servicios en `host` hace que los puertos queden directamente expuestos en la interfaz del host (`localhost`), facilitando el acceso desde el navegador del profesor/alumno sin depender del DNS interno de Docker.
- Trade-offs:
  - Pros: enlaces en la UI de Prometheus suelen ser clicables desde el host (`http://localhost:...`), diagnóstico más directo desde la máquina local.
  - Contras: menos aislamiento de red, posibles conflictos de puertos y menor seguridad en entornos multiusuario.

Si prefieres volver al modo bridge para experimentar la resolución por nombre de servicio, elimina `network_mode: "host"` en `docker-compose.yml`, restaura el mapeo de puertos (`ports:`) y usa los comandos de diagnóstico in-network descritos arriba.